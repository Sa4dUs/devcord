use crate::db::db_errors::UserInsertError;
use crate::db::password_hasher::verify_password;
use crate::models::{auth_info::AuthInfo, user_info::UserInfo};

use sqlx::PgPool;
use uuid::Uuid;

// For inserting users there's no need to specify the id (it's autogenerated)
pub async fn insert_user(
    pool: &PgPool,
    username: &str,
    hashed_password: &str,
    email: &str,
    telephone: Option<&str>,
) -> Result<UserInfo, UserInsertError> {
    let id = Uuid::new_v4().to_string();
    let user = sqlx::query_as::<_, UserInfo>(
        r#"
        INSERT INTO users (id, username, hashed_password, email, telephone)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, username, hashed_password, email, telephone
        "#,
    )
    .bind(&id)
    .bind(username)
    .bind(hashed_password)
    .bind(email)
    .bind(telephone)
    .fetch_one(pool)
    .await?;

    Ok(user)
}

pub async fn change_password(
    pool: &PgPool,
    username: &str,
    hashed_password: &str,
) -> Result<(), sqlx::Error> {
    sqlx::query(
        r#"
        UPDATE users
        SET hashed_password = $1
        WHERE username = $2
        "#,
    )
    .bind(hashed_password)
    .bind(username)
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn delete_user(pool: &PgPool, username: &str) -> Result<bool, sqlx::Error> {
    let result = sqlx::query(
        r#"
        DELETE FROM users
        WHERE username = $1
        "#,
    )
    .bind(username)
    .execute(pool)
    .await?;

    Ok(result.rows_affected() > 0)
}

pub async fn get_user_by_username(
    pool: &PgPool,
    username: &str,
) -> Result<Option<AuthInfo>, sqlx::Error> {
    let result = sqlx::query_as::<_, AuthInfo>(
        r#"
        SELECT id, username, hashed_password
        FROM users
        WHERE username = $1
        "#,
    )
    .bind(username)
    .fetch_optional(pool)
    .await?;

    Ok(result)
}

pub async fn verify_user_credentials(
    pool: &PgPool,
    username: &str,
    password: &str,
) -> Option<AuthInfo> {
    match get_user_by_username(pool, username).await {
        Ok(Some(user)) if verify_password(password, &user.hashed_password) => Some(user),
        _ => None,
    }
}
