use crate::db::password_hasher::verify_password;
use crate::models::user_info::UserInfo;
use sqlx::{Error as SqlxError, PgPool, Row};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum UserInsertError {
    #[error("The username is already taken")]
    UsernameTaken,
    #[error("Database not working properly")]
    Database(#[from] SqlxError),
}
// For inserting users there's not need to specify de id (it's autogenerated)
pub async fn insert_user(
    pool: &PgPool,
    username: &str,
    hashed_password: &str,
    telephone: Option<&str>,
) -> Result<UserInfo, UserInsertError> {
    let res = sqlx::query_as::<_, UserInfo>(
        r#"
        INSERT INTO users (username, hashed_password, telephone)
        VALUES ($1, $2, $3)
        RETURNING id, username, hashed_password, telephone
        "#,
    )
    .bind(username)
    .bind(hashed_password)
    .bind(telephone)
    .fetch_one(pool)
    .await;
    match res {
        Ok(user) => Ok(user),
        Err(e) => {
            if let SqlxError::Database(db_err) = &e {
                //23505 is the error code when the UNIQUE is violated
                if db_err.code().as_deref() == Some("23505") {
                    return Err(UserInsertError::UsernameTaken);
                }
            }
            return Err(UserInsertError::Database(e));
        }
    }
}

pub async fn change_password(
    pool: &PgPool,
    username: &str,
    hashed_password: &str,
) -> Result<(), sqlx::Error> {
    sqlx::query(
        r#"
        UPDATE users
        SET hashed_password = $1
        WHERE username = $2
        "#,
    )
    .bind(hashed_password)
    .bind(username)
    .execute(pool)
    .await?;

    Ok(())
}

pub async fn delete_user(pool: &PgPool, username: &str) -> Result<bool, sqlx::Error> {
    let result = sqlx::query(
        r#"
        DELETE FROM users
        WHERE username = $1
        "#,
    )
    .bind(username)
    .execute(pool)
    .await?;

    Ok(result.rows_affected() > 0)
}

pub async fn verify_user_credentials(pool: &PgPool, username: &str, password: &str) -> bool {
    let result = sqlx::query(
        r#"
        SELECT hashed_password
        FROM users
        WHERE username = $1
        "#,
    )
    .bind(username)
    .fetch_one(pool)
    .await;

    match result {
        Ok(record) => {
            let hashed: String = record.get("hashed_password");
            verify_password(password, &hashed)
        }
        Err(_) => false,
    }
}
